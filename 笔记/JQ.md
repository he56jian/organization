#JQuery
>######说明：
>1. jq是由javascript代码编写成的一个成熟的框架库；
>2. 主要用来做特效，DOM节点的各种操作，ajax等等；
>3. 进行了功能操作之后返回的还是JQuery对象，用于链式操作；
>4. 要引入jq
>>1. 推荐使用CDN引入；(百度cdn、淘宝cdn库、bootcdn)就是在百度查找了静态资源公共库之后，导入时直接到入其对应的地址；
>2. 也可以直接下载jq的源码，然后引入；

>######版本:
>1. 1.X.X 几乎兼容所有浏览器，包括IE678，所以代码下相对多一点，性能低一些；
>2. 2.x.x 不兼容IE678，简化了大量代码；
>3. 3.x.x 不兼容IE678，引入了HTML5新的api；
>######检测jq是否引入：
>因为jq值开发了两个变量$ 和jQuery.所以可以用判断变量是否存在就可以； 

###$的用法：
>######说明：
>1. $()是一个函数；
>2. $()其参数几乎支持所有的css的选择器的写法；
>3. $()返回一个对象，相当于一个实例；实例对应的原型里面有很多方法，这些就是jquery给这个实例已经写好的方法；

$()获取节点的时候就会自动遍历；
使用.eq(n)筛选第n个元素；
$()及其方法返回的是jquest对象；
jq对象和Dom对象的互相转换
dom->jq  $(dom对象）
jq->dom  jq对象.get(序号)/jq对象[序号]

######$()参数：
用于获取jquest对象，或者添加加载事件
> 1. 字符串参数
> 2. dom对象/DomList对象；
> 3. 函数；当dom文档节点加载完成后触发的时间；$(function(){});其相当于$(document).ready(function(){});比window.onload快（因为window.onload要等所有元素加载完成；
> 4. 两个参数；$('p','#wrap')第一个在第二个里面;和$('#wrap p')一样和$('#wrap').find('p')一样；
> 5. $('<ul></ul>'),创建一个ul标签，并将其封装成jq对象；


###方法：
####.css()
>1. .css('color','red')：设置color为red
>2. .css('color'):获取color值，如果是列表的获取，就只获取第一个；
>3. .css('color',function(){return red}):设置；
####.eq(n):
>筛选第n个元素；返回一个新的jq对象；可以设置负数；
#####.each()其参数
>函数：遍历其jq对象，并执行；
>.each(function(a,b){})第一个形参为为当前dom对象的序号，第二个形参为当前dom对象；其this指向当前dom对象；
#####.length
>当前jq对象包含了多少个dom对象；
#####.index
>获取当前jq对象的序号；
>不传参数，获取当前元素在父级子元素里的序号；
>传参选择器，$p.index('.h')获取当前元素在选择器下的所有序号(即p在.h里的序号)；$p.index($('.h'))获取.h在p标签里的序号；
#####.data
>相当于.变量存值方式，添加自定义属性；
>.data('g',20);存值方式；
>用于防止和API冲突；
#####.removeData
>移出其自定义属性；
#####JQuery.noConflict()
>释放$的占用；
#####$.ajax();
>ajax是$私有属性；
>其参数为一个对象；
>其属性写入：type:‘get' ， //请求方式；
>url:'https://' ，//请求地址；data:{},//传递的数据；dataType:'json'//返回的数据格式，会自动预处理，如果没写会自动判断转换；success:function(data){ data传成dataType类型的数据 }   //成功后的执行；error:function(data){失败的执行}
###属性相关的api
#####.attr
>操作标签属性；通常用来操作不合法的标签属性，
>.attr('key','value');
######.prop
>操作标签属性；通常用来操作合法的标签属性；可以操作当前的值
注意：操作input的checked时，attr获取的是checked，而prop获取的是布尔值；
#####removeAttr/removeProp
>移除属性 
#####addClass('b')
>添加类名；
#####removeClass('b')
>移出类名
#####toggleClass('b')
>有就删，没有就加；
#####.html()
>相当于innerHtml
>传值为设置，不传参数为获取；
#####.val()
>相当于value值；
#####.offset()
>返回的是一个位置对象，距离文档的距离;会把margin计算进去；
>传入对象参数为设置位置；
#####.position()
>返回一个对象；距离定位父级边界的距离；不会把margin计算进去；
>不能接收参数进行设置；
#####$(window).scrollTop()
>滚动条距离，
>不设置参数，获取滚动距离；
>加入一个参数，设置滚动距离；
#####$(window | document.documentElement).scrollLeft()
>水平滚动条距离
>不设置参数，获取滚动距离；
>加入一个参数，设置滚动距离
#####.width()
>相当于width
>添加参数设置；设置只能改width
#####.innerWidth()
>相当于js的clientWidth; width+padding
>添加参数设置;设置只能改width
#####.outerWidth()
>相当于js的offsetWidth;width+padding+border;
>添加参数设置；设置只能改width
#####.height()
>和width类似；
#####.filter
>过滤出其中一个；
>参数：
>>选择器,通过选择器筛选出对应的jq对象；
>其和$要传的参数一样
#####.hasClass()
>传入参数，用于判断是否存在class值
#####.is()
>用于判断是否存在；返回布尔值； 
>参数为字符串，用于判断是否包含供匹配当前元素集合的选择器表达式；
>参数为jq对象，用于匹配当前元素
>DOM元素，用于匹配元素；
#####.map()
>将一组元素转换成成其他数组；
>map有对应的返回值，each返回的是原本的jq对象；两个返回值不一样
#####.has()
>根据子级满足要求与否来判断是否选择其父级；
>$('p').has('a'),相当于选择有a标签子级的p 标签；
#####.not()
>和filter对立，not为去除
#####.slice(start,[end])
>选取匹配的子级；
>切取后返回一个新的对象；
#####.children()
>不加参数，选中所有子级；
>传了参数，对所有子级进行筛选
#####.find()
>要传参数，其查找其所有后代中匹配的；
>传入*,查找其所有后代；
#####.next()
>选中的是下一个兄弟
#####.nextAll()
>选中的是后面所有兄弟
#####.nextUntil(ele)
>选中的是后面兄弟直到ele选中的兄弟
#####.prev()
>和next()类似；
#####.sibling()
>不加参数；选中其的全部兄弟
>加入参数，进行筛选；
#####.offsetParent()
>查找其定位父级，没有的话为html；
#####.parent()
>默认为body;
>可以传入参数筛选；；
#####.parents()
>查找所有的父带们；
>可以传入参数筛选；
#####.add()
>原本的标签在加参数标签组合在一起再返回；
#####.contents()
>查找匹配元素内部的所有的子节点，包括文本节点，如果元素时一个iframe，则查找文档内容；
#####.end()
>返回一个新的jq对象，返回前一个对象状态；（如果原本的jq对象，进行查找所有子级后，变成了新的所有子级的jq对象，使用end()之后，就变成了原本的jq对象）
#####.append()
>把参数添加到对象
>插入的是子类位置；
>加入参数，添加文本；不会把原本的内容覆盖；和js的appendchild类似，不会覆盖其绑定的时间；
>可以添加html格式，
>可以添加标签对象；
>可以添加jQuery对象；
>如果添加的是原本存在的jQuery对象或者dom对象，它会把存在的对象移动到新的位置；
#####.prepend()
>往前面添加参数；
#####.appendTo();
>把jq对象添加到参数里；
#####.after()
>在匹配的元素之后插入内容，和append类似，但是这个插入的是兄弟位置；
#####.insertAfter()
>把匹配的元素插入参数元素后面；
#####.before()
>在匹配元素前面兄弟插入内容；
#####.inserBefore()
>把匹配的元素插入参数元素前面；
#####.wrap()
>在匹配元素上添加一个父级；
>参数是原本有的元素，会自动复制；
#####.unwrap()
>删除父节点；
####.wrapAll()
>把第一个节点添加一个参数父级，其他的节点移动到该父级下；
#####.wrapInner()
>给匹配的元素子元素加一个壳
#####.empty()
>把元素情况，相当于innerHTML=''
#####.remove()
>移除自身；
#####.clone()
>把匹配元素克隆一份；
>第一个参数，布尔值，判断事件处理函数是否会被复制；
>第二个参数，布尔值，判断是否要复制子元素；

###事件
都是函数式的写法；
注意jq没有滚轮事件；要添加一个插件jquery-mousewheel;
#####.click()
>参数为事件函数；
>其this指向dom对象，指向操作的dom对象；其函数中也有形参事件对象Event，是jq重新封装过的Event;如果引入的是兼容版本，就不用考虑事件对象的各种兼容性；
>它是addlinstener绑定的事件，所有可以添加多个
#####.on()
>事件绑定；在click这些事件都是调用的on()绑定；
>参数一写入事件，参数二写入事件函数；
>参数一写入一个对象，格式为{'click.name':function(){}}内部参数一为事件类型，可以用.name方式取名字用于解绑，参数二吸入对象，格式一样，添加多个绑定事件
>事件委托：三个参数，事件类型，事件执行对象，函数；其this指向当前子类；
#####.off()
>解除事件绑定；参数写事件就行；加上.name解除固定的事件；解绑多个就在参数里加空格就行；
#####.read()
>只给document加
#####.one()
>事件的绑定方式；表示一次性事件；
#####.hover(
>添加两个参数，相当于两个事件的组合；第一个为mouseenter,mouseleave

###工具
#####$.each()
>传入数组和对象，和数组的变量一样；
#####$.extend()
>在里面传入参数，是给$的属性拓展；
#####$.fn.extend()
>在里面传入键值对，给$的事件对象拓展；
###效果：
#####.show()
>相当于display：block；根据原本的display的类型，来加入；如果是span标签，写成了block，使用show()后，会变会inline;
>加入时间参数（slow表示800ms,fast为300ms，nomal为500ms，也可以填数字），会在时间内变大宽高，及透明的，可以加一个回调函数，在动画完成后执行，在回调前面添加可以添加曲线；
>会改变布局
#####.hide()
>相当于display:none;
>加入时间参数，会在时间内变小宽高，及透明度，再加入一个回调函数，在动画执行完成后执行；还想传入动画曲线，要在回调前面添加，默认swing,另一种为linear
>会改变布局
#####.toggle()
>根据当前展示状态切换，会改变布局
#####.fadeIn
>淡入
>不写参数，会很快；默认为300ms;
>可以加回调函数，和曲线，和时间
#####.fadeOut
>淡出
>不写参数，会很快；默认为300ms;
>可以加回调函数，和曲线，和时间
>只改变透明的，最后变成display:none
#####.fadeTo
>必须给时间，然后到变成某一个指定透明度状态
#####.fadeToggle
>根据当前展示状态切换；
#####.slideDown
>只变成高度height;
>向下展开；
>其展开判断的根据是display：none时;
>从0展开到设置的高度；
>只写一个参数表示动画持续时间；
>写两个，一个表示动画持续时间，一个表示回调，
>写三个参数，一个表示动画持续时间，一个表示曲线，一个表示回调
>最后也是变为di
#####.slideUp
>只变成高度height;
>向上收起；
>从当前高度变为0；变的同时会设置一个overflow：hidden;并自动添加padding/margin:0;
>只写一个参数表示动画持续时间；
>写两个，一个表示动画持续时间，一个表示回调，
>写三个参数，一个表示动画持续时间，一个表示曲线，一个表示回调
#####.slideToggle
>根据display状态，判断是否展开；
#####.animate()
>第一个参数为对象，变化的值的组合；
>第二个参数写时间，默认300
>第三个参数为曲线；
>第四个参数为回调；
>它会把动画列队，在第一个动画执行后再执行下一个
>不能改变颜色，要加个插件
#####.stop()
>清除前面的所有的队列
>接收两个参数，第一个参数表示要不要清除队列，第二个参数表示清除后位置在哪（第一种为当前位置false(默认)，第二种会把属性立马变成目标值（true)）
###队列
#####.delay()
>延迟，
>参数写入延迟时间；
>延迟的后面必须是一个队列才行；
>正常的代码不会延迟；
>动画就是一个队列
#####.queue()
>规定一个队列；
>传入参数函数，在函数内部传入需要加入队列的操作；
>如果不是队列，就会直接执行，再执行队列；
>加一个.queue()就是一个队列，如果要执行下一个队列，要取消队列；
#####.dequeue()
>手动退出队列，当前队列已经结束；


vue和angla用于根据数据渲染页面
react用于移动端，html和代码混编


